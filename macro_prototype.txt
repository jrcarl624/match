// todo make all non byte strings byte strings

// todo: formatter should be able to format macros, a macro can define what formatting to use


    
    // builtins
    

    builtin patten Symbol

    buitin rule peek
    builtin rule 

    // keywords

    pattern

    template 

    statement

    group

    namespace 
    
    rule 

    for

    while

    loop
    
    if

    else

    elif

    switch 
    case 
    default

    // primitives
    char // char
    u32 // uint
    i32 // int
    f32 // float
    
    string // custom string struct
    
    u64 // u64
    i64 // i64
    
    bool // u8
    
    // range 

    let custom_range<u32> = range(start,end) -> range<u32>  
    
    // array
    
        
    let customArray:array<u32, 10> = [1,2,3,4,5,6,7,8,9,10];
    let customInclusiveSlice:slice<u32> = customArray[1, 5];
    let customSlice:slice<u32> = customArray[1, 5];

    let customVector:array<u64, 100> = [1,2,3,4,5,6,7,8,9,10];

    vector/array/slice = len() -> u32
    vector/array/slice = at(index:u32) -> T
    vector/array/slice = front() also start() -> u32
    vector/array/slice = back() also end() -> u32
    vector/array/slice = slice_range(range:range<u32>) -> slice<>
    vector/array/slice = slice(start:u32,end:u32)

    vector = push_back(element)
    vector = pop_back()
    slice = slide(amount:i32)

    
    for i in range(customArray.start(),customArray.end()) {
        print(customArray.at(i));
    }

    
    

    // operators
    | // bitwise or
    || // or
    & // bitwise and
    && // and
    ^ // bitwise xor
    ! // not
    << // shift left
    >> // shift right
    + // add
    - // subtract
    * // multiply
    / // divide
    % // modulo
    == // equal
    != // not equal
    < // less than
    > // greater than
    <= // less than or equal
    >= // greater than or equal
    = // assign
    . // access
    : // type
    :: // namespace
    ? // optional
    -> // return
    

    // pattern ops 


    
    template Delimit(start: Literal, middle: Pattern, end?: Literal = start)-> Pattern {
        start middle end
    }

    // [1,2,3,4,5]

    template SquareBrackets(middle:Pattern) {
        Delimit(b'[',middle,b']')
    };

    abstract template Seperation


    // 1,2,3,4,5
    // 
    template SeparatedList(pattern:Pattern, separator:Pattern, optional_trailing:bool) -> Pattern {
        repeat(pattern separator)
        
        if optional_trailing {
            ?pattern
        }
    }


    builtin rule repeat(pattern:Pattern) {
        
        loop {
            match(pattern)

        }
    }
            
    builtin fn ReadBack() -> char: {
        return global::HeadLocation-1;
    }

    builtin fn Read() -> char: {
        return global::HeadLocation;
    }
    

    builtin rule start_of_line()  {
        if ReadBack() == '\n' {
            return true
        }
        return false
    } 
    
    
    
    abstract template Delimit(start: Pattern, middle: Pattern, end: Pattern = start)-> Pattern {
        start middle end
    }


    abstract template Parentheses(middle:Pattern) -> {
        Delimit(b'(',middle,b')')
    };

    template SeparatedList(pattern:Pattern, separator:Pattern, optional_trailing:bool) -> Pattern {
        
        repeat(pattern separator)
        
        
        if optional_trailing {
            ?pattern
        }
    }
    

    template RoundList(middle:Pattern) -> {
        pattern comma_seperated = SeparatedList(self::middle, b',', true);

        Parentheses(comma_seperated);
    }

    pattern Type...;

    pattern TupleTypeDefinition = RoundList(Type);
    rule IsAscii(loc:char) -> bool {
        if loc > 127 {
            return false
        }
        return true
    }

    rule IsAlpha(loc:char) -> bool {
        if (loc in range('A','Z') | range('a','z')) {
            return true
        }
        if (loc in ) {
            return true
        }
        return false
    }

    rule IsNumeric(loc:char) -> bool {
        if (loc in range('0','9')) {
            return true
        }
        return false
    }

    rule IsAlphaNumeric(loc:char) -> bool {
        return IsAlpha(loc) || IsNumeric(loc)
    }
    
   


    pattern Symbol
    
    rule Negate() -> {
        if (peek() != '-') {
            return false
        }

        next_pass {
            var currentLocation:u64 = global::HeadLocation;
            if (ReadToken(currentLocation+1) == Symbol && ReadToken(currentLocation-1) != Symbol) {
                return true
            }
            else 
            {
                return false
            }
        }
    }














    
     builtin type  PatternSequence



    abstract template BasicCapture<a, b, c = a> {
        a b c
    };

    
    pattern SquareBrackets : BasicCapture<'[', any, ']'> {}



    








    delimiters: b'{' | b'}' | b'(' | b')' | b';' | b'!' | b'=' | b'|'|b':'|b','|b'<'|b'>' | b'?'|b'.',
    // two char delimeters

    newline: b'\n',

    other_whitespace: b'\t' | b0xC | b'\r' | b' ',

    whitespace: other_whitespace!() | newline!(),
    // can use raw num bytes
    any: 0..=255,

    group keyword {
        // Control Flow

        statement Something: Keyword = "SomethingValue"




        
    pattern Keyword {
        ident: Identifier,

        Keyword() -> {
            self::ident ansi::Whitespace
        }
        }

        /// The if keyword
        statement IF:Keyword = Keyword("if");
        statement UNLESS:Keyword = "unless"; /// The unless keyword, like elif
        statement ELIF:Keyword = "elif"; /// The else keyword
        statement ELSE:Keyword = "else"; /// The else keyword

        // Loops
        statement WHILE:Keyword = "while"; /// The while keyword
        statement FOR:Keyword = "for"; /// The for keyword
        statement LOOP:Keyword = "loop"; /// An endless loop

        // Pattern Matching
        statement CASE:Keyword = "case"; ///  The case keyword
        statement DEFAULT:Keyword = "default"; /// The default keyword
        statement MATCH:Keyword = "match" /// The match keyword
        statement SWITCH:Keyword = "switch"; /// The switch keyword

        // Loop Control
        statement BREAK:Keyword = "break"; /// The break keyword
        statement CONTINUE:Keyword = "continue"; /// The continue keyword

        // Function Declaration
        statement FUNCTION:Keyword = "fn"; /// The function keyword
        statement ANONYMOUS_FUNCTION:Keyword = "lambda"; /// The lambda keyword

        // Threading
        statement THREAD:Keyword = "thread"; /// The thread keyword
        statement TENSOR:Keyword = "tensor"; /// The tensor keyword

        // Meta Programming
        statement MACRO:Keyword = "macro"; /// The macro keyword
        statement OPERATOR:Keyword = "op"; /// The operator keyword

        // Function Modifier
        statement ASYNC:Keyword = "async"; /// Denotes an asynchronous function
        statement DELEGATE:Keyword = "delegate"; /// The delegate keyword
        statement INLINE:Keyword = "inline"; /// Denotes an inline function

        // Function Control
        statement RETURN:Keyword = "return"; /// Returns a value from a function

        // Data Structures
        statement CLASS:Keyword = "class"; /// The class keyword
        statement STRUCT:Keyword = "struct"; /// A type structure without methods
        statement ENUM:Keyword = "enum"; /// An enum
        statement UNION:Keyword = "union"; /// A union

        // Type Declarations
        statement INTERFACE:Keyword = "interface"; /// An interface without default methods
        statement ABSTRACT:Keyword = "abstract"; /// An interface with default methods
        statement TYPE_ALIAS:Keyword = "type"; /// A type alias

        // Type Handling
        statement TYPEOF:Keyword = "typeof"; /// Returns the type of a variable
        statement SIZEOF:Keyword = "sizeof"; /// Returns the size of a type in bytes
        statement INSTANCE_OF:Keyword = "instance_of"; /// Checks if a variable is an instance of a type

        // Error Handling
        statement TRY:Keyword = "try"; /// The try keyword
        statement CATCH:Keyword = "catch"; /// The catch keyword
        statement EXCEPT:Keyword = "except"; /// The except keyword
        statement FINALLY:Keyword = "finally"; /// The finally keyword
        statement THROW:Keyword = "throw"; /// Throws an error

        // Core
        statement WITH:Keyword = "with"; /// The with keyword

        // Access Modifier
        statement PRIVATE:Keyword = "private"; /// Accessible from a data structure only
        statement PROTECTED:Keyword = "protected"; /// Accessible from a data structure and its children
        statement PUBLIC:Keyword = "public"; /// Accessible from anywhere
        statement CONST:Keyword = "const"; /// A compile time constant
        statement FINAL:Keyword = "final"; /// A runtime constant, once set cannot be changed
        statement STATIC:Keyword = "static"; /// Denotes interior mutability
        statement UNDEF:Keyword = "undef"; /// Notates Undefined Behavior

        // Variable Declaration
        statement LET:Keyword = "let"; /// A mutable variable
        statement VAR:Keyword = "var"; /// The var keyword
        
        // Assignment modifiers
        statement AUTO:Keyword = "auto"; /// A variable with automatic type inference, let auto x = 3;
        statement AWAIT:Keyword = "await"; /// Waits for an asynchronous future to complete when assigned to a variable, let await x = async_fn();

        // Module Import
        statement IMPORT:Keyword = "import"; /// Imports a module
        statement INCLUDE:Keyword = "include"; /// Includes a file
        statement USING:Keyword = "using"; /// Uses a module
        statement FROM:Keyword = "from"; /// Imports a module from a package

        // Asynchronous Control
        statement YIELD:Keyword = "yield"; /// Yields a value from a generator
        // should be a modifier like let await 3= ...
        // and .await




    }




    builtin rule peek(pattern:Pattern) -> bool
    builtin rule LineStart;
    builtin rule LineEnd;

    builtin quantifier * = 0..;
    builtin quantifier + = 1..;
    builtin quantifier ? = 0..1;


    rule LineStart = if peek



    // todo: goto keyword

    template Delimit(start: Literal, middle: Pattern, end?: Literal = start)-> Pattern {
        start middle end
    }


    template SquareBrackets(middle:Pattern) {
        Delimit(b'[',middle,b']')
    };

    
    
    template Parentheses(middle:Pattern) -> Delimit(b'(',middle,b')');
    template CurlyBrackets(middle:Pattern) -> Delimit(b'{',middle,b'}');
    template AngleBrackets(middle:Pattern) -> Delimit(b'<',middle,b'>');


    template SeparatedList(pattern:Pattern, separator:Pattern, optional_trailing:bool) -> Pattern {
        (self::pattern self::separator)* if optional_trailing {self::pattern?}
    }

    template CommaSeparated(pattern:Pattern,optional_trailing:bool) -> Separated(self::pattern, b',', self::optional_trailing);
    template SemicolonSeparated(pattern:Pattern,optional_trailing:bool) -> Separated(self::pattern, b';', self::optional_trailing);

    template RoundList(middle:Pattern) -> Parentheses(SeparatedList(self::middle, b',', true));
    template SquareList(middle:Pattern) -> SquareBrackets(SeparatedList(self::middle, b',', true));
    template CurlyList(middle:Pattern) -> CurlyBrackets(SeparatedList(self::middle, b',', true));
    template AngleList(middle:Pattern) -> AngleBrackets(SeparatedList(self::middle, b',', true));

    template Tuple(elements:Type) as Type -> RoundList(elements);
    template Tuple(elements:Expression) as Expression -> RoundList(elements);




    // TODO: need a way to type an array
    template Array(elements:Expression) as Expression -> SquareList(elements);

    


    pattern Identifier {

        first: Alpha | Underscore,
        rest: self::first | Numeric,

        Identifier() -> {
            self::first self::rest*
        }
    }

    pattern TypeGeneric {
        name: Identifier,
        generics: AngleList(Type),

        TypeGeneric() {
            self::name self::generics?
        }
    }

    pattern Type {
        group name: Identifier,
        generics: TypeGeneric,

        Type() -> {
            self::name self::generics?
        }
    }

    group Type {
        name: Identifier,
    }

    abstract 
    

    group 


    // {{}}}{{{}{}}{}}}



    
    // var a = 3

    // func something()
    // {
    //     a++
    // }
    
    // return 3 + something() + a 

    
    // CustomIdentifier
    // uint64_t CIInt = ToRuntimeIdentifier("CustomIdentifier")

    // struct MatchData {
    //     char* start
    //     char* end
    //     uint8_t encoding
    // }

    // int i = 0;
    // int* p = &i;
    // return p;



    // struct MatchCase
    // {
    //     uint64_t identifier // this can be computed at compile time
    //     MatchData data
    //     MatchCase* children
    // }





    // {func();}
    // {
    //     0xdead
    //     0x00
    //     0x01
    //     0x02

    // }
    // {
    //     0xc0de
    //     0x02
    //     0x03
    //     0x00
    // }
    // [match1, match2, match3]

    group Name {

        things
    }
    
  
    agnostic pattern SquareBrackets<middle> : Parent[Delimit('"' ,middle, '"')]


    abstract pattern AbstractSearcher<start: Pattern, middle:Pattern ,end?: Pattern = start>
    {
        start;
        middle;
        end;
    }

    SquareBrackets foo = ...;

    foo.start

    pattern SquareBrackets : AbstractSearcher<'[', any, ']'> {}
        

    
    pattern TypedAssignmentTernary {
        
        type_specifier?: if self::has_type { ':' self::type } 
        assignment?: if self::HAS_ASSIGNMENT {'=' self::value},
        type_part?: if self::TYPE_OPTIONAL self::type_specifier? else self::type_specifier

        TypedAssignmentTernary(name:Identifier, type:Pattern, value:Pattern, TYPE_OPTIONAL:bool; HAS_TYPE:bool, HAS_ASSIGNMENT:bool ) -> {
            self::name self::type_part self::assignment
        }
    }


    // this is later
    // pattern InlineMetaAttribute {
    //     name: Identifier,
        

    //     MetaAttribute() -> {
    //         self::name 
    //     }
    // }



    pattern VariableDefinition(name:Identifier, type:Type, value:Expression)-> TypedAssignmentTernary(self::name, self::type, self::value, false, true);



    pattern GenericDefinition {

        name: Identifier,

        generic_item: TypedAssignmentTernary(Identifier, Type, Type),

        generics: AngleList(self::generic_item),

        GenericDefinition() {
            self::name self::generics
        }
    }






    pattern TypeAlias {
        keyword = Keyword(keyword::TYPE)
        name: Identifier,
        bounds: TypeGeneric,
        generics: GenericDefinition,
        setting:TypedAssignmentTernary(self::name self::generics, self::bounds, Type),

        TypeAlias() -> {
            self::keyword self::setting
        }
    }

    /*
    #[meta(...)]
        
        #[meta(...)]
     
        #[protocol(
        error = "TestError",
        fields((
            // if version is not specified it will default to the latest version
            java(encoding = "be"),
            bedrock(encoding = "le")
        ),
        (
            java(encoding = "var"),
            bedrock(encoding = "zigzag")
        ),
        (
            java(version = "2..34",len = "u8", inner(len = "u32_var") ),
            bedrock(version = "3..22",len = "u8",inner(len = "u32_be"))
        )
        )
    )]
     
     */

    
    pattern Meta {
        name: Identifier,
        values:SquareListList(TypedAssignmentTernary(Identifier, Type, Expression)),

        Meta() -> {
            self::keyword self::name self::values
        }
    }



    pattern KeywordHeader {
        keyword = self::
        name: Identifier,
        generics: AngleList(Type),


        KeywordHeader(keyword:string) -> {
            self::keyword self::name self::generics
        }
    }



    pattern Struct {
        keyword = Keyword(keyword::STRUCT),
        name: Identifier,
        generics: AngleList(Type),
        fields: CurlyList(VariableDefinition),

        Struct() -> {
            self::keyword self::name self::generics self::fields
        }
    }



    pattern Function {
        keyword: Keyword(keyword::FUNCTION),
        name: Identifier,
        parameters: RoundList(VariableDefinition, b',', true),
        return_type: Type,
        return_operator: ,
        body: ,

        Function() -> {
            self::keyword self::name self::parameters self::return_type self::body
        }
    }


    //pattern Indexing(index:Pattern) -> SquareBrackets(index);




    // enum QuotePrefix {
    //     Raw: "r",
    //     Binary: "b",
    //     Unicode: "u",
    //     Formatted: "f",
    // }




    pattern Quotes(prefix:QuotePrefix, inner:Pattern) ->{Delimit('"',middle)};




    // struct DoubleQuotes<MIDDLE>: Delimit<b'"',MIDDLE,b'"'> {
    //     middle: MIDDLE
    // },








    /// A patten that contains all the different types of patterns
    quantifier All;
    quantifier AtLeastOne;
    quantifier ZeroOrOne;

    /// Some Sort of Pattern
    statement Pattern

    /// States that the pattern is optional at the end
    statement OptionalAtEnd<>

    statement RequiredAtEnd

    abstract Separator<PAT,LIT> {
        pattern: Pattern = PAT,
        separator: Literal = LIT,
        layout() -> {
            self::pattern self::separator
        }
    },



    /// Required Whitespace
    pat HorizontalWhitespace:Literal = b' ' | b'\t' | b'\r' | b0xC;
    struct VerticalWhitespace:Literal = b'\n';

    pat Whitespace:Literal = HorizontalWhitespace | VerticalWhitespace;



    /// A structure that

    abstract SeparatedGroup<PAT,SEPARATOR,START,END,END_REQUIRED>: Delimit<START,Separator<PAT,SEPARATOR>,END>{

    }



    statement Expression:Pattern;

    struct Brace<REQUIRED_KEYWORD[]>: SeparatedGroup<Expression, ";", "{", "}", true> {

        required_keyword: REQUIRED_KEYWORD


    };

    alias CommaList<Pat,Start>: SeparatedGroup<Pat, OptionalAtEnd<",">>;

    /// A pattern that is a literal
    statement Literal: Pattern;



    interface List:SeparatedGroup {

    },


    scope:SeparatedGroup {
        start: '{',
        end: '}',
        separator: ';',
        // like a fn scope can contain return, break, continue, and other scopes
        can_contain(pattern:Pattern) -> {
            pattern
        }
    },
    /// Notates that something is a type declaration
    statement Type:Pattern;




    structure: {

    }



    scope : {
        start: '{',
        end: '}',
        separator: ';',
        // like a fn scope can contain return, break, continue, and other scopes
        can_contain(pattern:Pattern) -> {
            pattern
        }
    }


    pattern Keyword {
        ident: Identifier,

        Keyword() -> {
            self::ident ansi::Whitespace
        }
    }

    abstract Pattern: {
        // Operator-specific documentation must be defined in subclasses
        fn doc(&self) -> String;
    }


    inbuilt {
        abstract Pattern;

        abstract Literal extends Pattern;
        abstract String extends Literal;
        abstract Number extends Literal;
        abstract Char extends Literal;
        abstract Boolean extends Literal;
    }

    group math {
        use super::ansi::punctuation::{Plus, Minus, Asterisk, Slash, Percent, CircumflexAccent,
            CommercialAt, Ampersand,Not, VerticalLine, Tilde, Dollar, Hash, GraveAccent,
            LowLine, Bang, Colon, Semicolon, LessThan, GreaterThan, Equals};

        alias Add: Plus;
        alias Subtract: Minus;
        alias Multiply: Asterisk;
        alias Divide: Slash;
        alias Modulo: Percent;
        alias Power: CircumflexAccent;
        alias Factorial: Bang;
        alias BitwiseAnd: Ampersand;
        alias BitwiseOr: VerticalLine;
        alias BitwiseXor: Tilde;
        pattern BitwiseNot: Not | Bang;
        alias MatrixMultiply: CommercialAt;

        alias GreaterThan: GreaterThan;
        alias LessThan: LessThan;

        pattern GreaterThanOrEqualTo: GreaterThan+Equals;
        pattern LessThanOrEqualTo: LessThan + Equals;
        pattern EqualTo: Equals+Equals;

        /// The not equal to operator
        pattern NotEqualTo: Bang + Equals;

        /// The strict equal to operator
        pattern StrictEqualTo: Equals + Equals + Equals;

        /// The strict not equal to operator
        pattern StrictNotEqualTo: Bang + Equals + Equals;

        /// The assignment operator
        alias Assign: Equals;

        pattern AddAssign: Plus + Equals;
    }

    group brackets {
        group round {
            use super::punctuation::{LeftParenthesis, RightParenthesis};
            alias Open: LeftParenthesis;
            alias Close: RightParenthesis;
        }
        group square {
            use super::punctuation::{LeftBracket, RightBracket};
            alias Open: LeftBracket;
            alias Close: RightBracket;
        }

        group curly {
            use super::punctuation::{LeftCurlyBracket, RightCurlyBracket};
            alias Open: LeftCurlyBracket;
            alias Close: RightCurlyBracket;
        }

        group angle {
            use super::punctuation::{LessThan, GreaterThan};
            char Open: LessThan;
            char Close: GreaterThan;
        }
    }


    group ansi {


        enum Control {
            Null: 0x0;
            Enquiry: 0x5;
            Acknowledge: 0x6;
            Bell: 0x7;
            Backspace: 0x8;
            LineFeed: '\n';
            VerticalTab: 0xB;
            FormFeed: 0xC;
            CarriageReturn: '\r';
            ShiftOut: 0xE;
            ShiftIn: 0xF;
            DataLinkEscape: 0x10;
            DeviceControlOne: 0x11;
            DeviceControlTwo: 0x12;
            DeviceControlThree: 0x13;
            DeviceControlFour: 0x14;
            NegativeAcknowledge: 0x15;
            SynchronousIdle: 0x16;
            EndOfTransmissionBlock: 0x17;
            Cancel: 0x18;
            EndOfMedium: 0x19;
            Substitute: 0x1A;
            Escape: 0x1B;
            FileSeparator: 0x1C;
            GroupSeparator: 0x1D;
            RecordSeparator: 0x1E;
            UnitSeparator: 0x1F;
            Delete: 0x7F;
        }

        use Control::{Tab, LineFeed, CarriageReturn, FormFeed, VerticalTab, Space};

        enum Whitespace {
            Newline: LineFeed;
            Return: CarriageReturn;
            HorizontalTab: Tab;
            VerticalTab: VerticalTab;
            FormFeed: FormFeed;
            Space: ' ';
        }

        enum Punctuation {
            CommercialAt: '@';
            Backslash: '\\';
            CircumflexAccent: '^';
            Underscore: '_';
            GraveAccent: '`';
            VerticalLine: '|';
            Tilde: '~';
            Bang: '!';
            DoubleQuote: '"';
            Hash: '#';
            Dollar: '$';
            Percent: '%';
            Ampersand: '&';
            SingleQuote: '\'';
            LeftParenthesis: '(';
            RightParenthesis: ')';
            Asterisk: '*';
            Plus: '+';
            Comma: ',';
            Minus: '-';
            Period: '.';
            Slash: '/';
            Colon: ':';
            Semicolon: ';';
            LessThan: '<';
            Equals: '=';
            GreaterThan: '>';
            Question: '?';
            LeftBracket: '[';
            RightBracket: ']';
            LeftCurlyBracket: '{';
            RightCurlyBracket: '}';
            Not:'¬';
        }



        enum LatinCapital {
            A: 'A';
            B: 'B';
            C: 'C';
            D: 'D';
            E: 'E';
            F: 'F';
            G: 'G';
            H: 'H';
            I: 'I';
            J: 'J';
            K: 'K';
            L: 'L';
            M: 'M';
            N: 'N';
            O: 'O';
            P: 'P';
            Q: 'Q';
            R: 'R';
            S: 'S';
            T: 'T';
            U: 'U';
            V: 'V';
            W: 'W';
            X: 'X';
            Y: 'Y';
            Z: 'Z';
        }

        enum LatinSmall {
            A: 'a';
            B: 'b';
            C: 'c';
            D: 'd';
            E: 'e';
            F: 'f';
            G: 'g';
            H: 'h';
            I: 'i';
            J: 'j';
            K: 'k';
            L: 'l';
            M: 'm';
            N: 'n';
            O: 'o';
            P: 'p';
            Q: 'q';
            R: 'r';
            S: 's';
            T: 't';
            U: 'u';
            V: 'v';
            W: 'w';
            X: 'x';
            Y: 'y';
            Z: 'z';
        }

        enum Digits {
            Zero: '0';
            One: '1';
            Two: '2';
            Three: '3';
            Four: '4';
            Five: '5';
            Six: '6';
            Seven: '7';
            Eight: '8';
            Nine: '9';
        }

        pattern Alpha: LatinCapital | LatinSmall;
        pattern Alphanumeric: Alpha | Numeric;
        alias Numeric: Digits;

        pattern HorizontalWhitespace: Whitespace::Space | Whitespace::Tab | Whitespace::CarriageReturn | Whitespace::FormFeed | Whitespace::VerticalTab;
        pattern VerticalWhitespace: Whitespace::Newline;

        // these have to be very explicit
    }

    use ansi::{Alpha,Whitespace,Numeric,Punctuation::{self,Underscore,Period,DoubleQuote}};
















    pattern Type: Pattern {
        name: Identifier,
        generics: Delimit<CommaList<Type>>,

        Type() -> {
            self::name self::generics?
        }
    }







    marker Primitive: Pattern;

    pattern String: Delimit<DoubleQuote, All> + Primitive {
        fn skip() -> {
            self::backslash super::start
        }
    }

    pattern Char: Delimit<SingleQuote, All> + Primitive {
        fn skip() -> {
            self::backslash super::start
        }
    }

    group number {

        use super::ansi::{Numeric,Period,Alphanumeric};


        enum Prefix {
            Binary: "0b",
            Octal: "0o",
            Hexadecimal: "0x",
        }

        enum Endian {
            Little: "le",
            Big: "be",
            Native: "ne",
        }

        enum IntegerSuffix {
            u8: "u8",
            u16: "u16",
            u32: "u32",
            u64: "u64",
            u128: "u128",
            i8: "i8",
            i16: "i16",
            i32: "i32",
            i64: "i64",
            i128: "i128",
        }

        enum FloatSuffix {
            f32: "f32",
            f64: "f64"
        }


        /// The exponent part of a number
        pattern Exponent {
            e: ansi::LatinCapital::E | ansi::LatinSmall::E
            sign: math::Add | math::Subtract,
            multiplier: Numeric+,

            Exponent() -> {
                self::e self::sign? self::multiplier
            }
        }

        pattern Binary:Literal {
            prefix: Prefix::Binary,
            number: Numeric,

            Binary() -> {
                self::prefix self::number
            }
        }

        const MAX_INT_SIZE = 128;


        enum NumberFormat {
            Decimal: Numeric+,
            Binary: "0b" + ('1' | '0'){1,MAX_INT_SIZE},
            Octal: "o" + ('0'..'7'){1,MAX_INT_SIZE/8},
            Hexadecimal: "x",
        }


        pattern Float:Literal {
            negative: math::Subtract,
            number: ,
            fractional:  Numeric+,
            exponent: Exponent,
            dot:Period,
            suffix: FloatSuffix,

            Float() -> {
                self::negative? self::integer?  (self::dot self::fractional)? self::exponent? self::suffix?
            }
        }

        enum NumberDelimiter {
            Comma: ',',
            Underscore: '_',
        }


        pattern Number:Literal {
            integer: Numeric+,
            fractional: Period Numeric+,
            exponent: Exponent,

            Number() -> {
                self::integer self::fractional? self::exponent?
            }
        }

        pattern Integer:Literal {
            decimal:Prefix
            layout() -> {
                self::decimal | self::binary | self::octal | self::hexadecimal
            }
        }







    }



    /// A boolean value
    pattern Boolean: Literal {
        true: "true",
        false: "false",
        layout() -> {
            self::true | self::false
        }
    }

    abstract VariableDefinition



    group function {
        abstract Function extends Pattern {
            // like inline or static
            meta: Pattern[],
            name: Identifier?,
            parameters: Delimit<CommaList<VariableDefinition>>,
            return_type: Type,
            body: Brace<Pattern>,
        }




    }


    group operator {

        meta Expression is builtin::Pattern;

         // Abstract base class for operators to avoid redundancy
        abstract Operator is Pattern {
            symbol: Pattern;
            identifier: Pattern;
            type: OperatorType;
            precedence: number;
            associativity: Associativity;

            // converts the op to a function call.
            fn to_function() -> {
                self::identifier function::call
            }
        }

        abstract PrefixOperator{

            rhs: Expression,
            operator: Operator,

            Prefix(identifier:Pattern, symbol:Pattern,  precedence:Number) -> {
                self::operator {
                    identifier,
                    symbol,
                    type: OperatorType::Unary,
                    precedence,
                    associativity: Associativity::RightToLeft,
                };
            }





        }




        // what do i call this type of operator |x| where it is surrounded by two things





        abstract PrefixExpression is OperatorExpression {
            PrefixExpression() {
                operator: Prefix,
                lhs: Expression,
            }
        }

        abstract Infix is OperatorExpression {
            Infix() {
                operator: Operator,
                lhs: Expression,
                rhs: Expression,
            }
        }


        abstract Prefix is Operator {
            Prefix( identifier:Pattern, symbol:Pattern,  precedence:Number) -> {
                Super {
                    identifier,
                    symbol,
                    type: OperatorType::Unary,
                    precedence,
                    associativity: Associativity::RightToLeft,
                };

                self
            }
        }




        abstract Infix is Operator {

            rhs: Expression,
            lhs: Expression,


            Infix() {
                Super {
                    identifier,
                    symbol,
                    type: OperatorType::Binary,
                    precedence,
                    associativity: Associativity::LeftToRight,
                };
                self::lhs super self::rhs
            }
        }

        abstract Postfix is Operator {

            Postfix() {
                Super {
                    identifier,
                    symbol,
                    type: OperatorType::Unary,
                    precedence,
                    associativity: Associativity::LeftToRight,
                };

                self::lhs super
            }
        }





        abstract Ternary<RHO,LHO> is Operator {
            rhs: RHO,
            lhs:


            Ternary() {
                Super {
                    identifier,
                    symbol,
                    type: OperatorType::Ternary,
                    precedence,
                    associativity: Associativity::LeftToRight,
                };

                self::lhs super self::middle super self::rhs
            }
        }




        /// The type of operator
        enum OperatorType {
            // Binary operators take two operands
            Binary,
            // Unary operators take one operand
            Unary,
            // Ternary operators take three operands
            Ternary,
        }

        enum Associativity {
            /// Evaluates from left to right
            LeftToRight,
            /// Evaluates from right to left
            RightToLeft,
        }

        /// Assigns the value of the right operand to the left operand.
        struct Assignment is Operator {
            symbol: super::math::Assign,
            type: OperatorType::Binary,
            precedence: 1,
            associativity: Associativity::RightToLeft,
        }

        struct EqualTo is Operator {
            symbol: "==",
            type: OperatorType::Binary,
            precedence: 2,
            associativity: Associativity::LeftToRight,
            doc: "Checks if the left operand is equal to the right operand",
        }



    }



    variable: {

        prefix: {
            mutable:{
                def: "~" |"mutable",
                layout() -> {
                    self
                }
            },
            macro_invocation: {},
            static: "static",
            const: "const",

        },


        defined_as: ":",

        layout() -> {
            self::prefix super::identifier self::defined_as super::type
        }
    },



    function : {
        keyword: "fn",

        param : {
            start: '(',
            end: ')',
            suffix: {
                error: '?',
                layout() {// declares the order
                    error
                }
            }

            middle*: {
                separator:','

                layout() -> {
                    ::variable self::separator*?  // optional end is *?
                }
            }

            layout() -> {
                self::start self::middle*? self::end self::suffix
            }



        },


        layout() -> {
            self::keyword self::param self::return error
        }

    },

    variable_definition : {
        // let ...
    }

    fn fizz_bizz (ffo:u8,f:u8)

    variable_type: {
        start: b":",
        end: b";",
        separator: b",",
    },

    method : {
        instance_call: b'.',
        static_call: b"::",
    },




    macro: {
        call: b'!',
    }




    fn_call_suffixes: macro_call!(),

    string_quotes: b'"',
    char_quotes: b'\'',

    quotes: string_quotes!() | char_quotes!(),

    backslash: b'\\',

    // raw | binary | unicode | formatted
    quote_prefixes: b'r' | b'b'| b'u'| b'f',
    // TODO: integrate this here ^
    prefixed_quotes: b"r\"" | b"b\""| b"u\""| b"f\"",

    // escape sequences
    // should we include regexp escape sequences in helix?
    // newline | carriage return | tab | null | hex | unicode | unicode extended | single quote
    escape_sequences: b"\\n" | b"\\r" | b"\\t" | b"\\0" | b"\\x" | b"\\u" | b"\\U" | b"\\'",


    two_len_ops: b"==" | b"!=" | b"<=" | b">=" | b"//" | b"**" |
    b"<<" | b">>" | b"r+" | b"r-"| b"r*" | b"r/" | b"r%" | b"r&" | b"r|" |
    b"r^" | b"+=" | b"-=" | b"*=" | b"/=" | b"%=" | b"&=" | b"|=" | b"^=" |
    b"=>" | b"@=" | b"->" | b"<-" | b"<=" | b">=" | b"&&" | b"--" |
    b"::" | b"||" | b"++" | b"__" | b"?=",



    three_len_ops: b"===" | b"!==" | b"..." | b"r//" | b"r**" | b"r<<" | b"r>>" | b"//=" | b"**=" | b"<<=" |
    b">>=" | b"??" | b"|:",

    // hex: numeric!() | b'a'..=b'f' | b'A'..=b'F',


    // method_call: b'.',
    // static_method_call: b"::",
    // method_error: b'?',


    // fn_definition_error_suffix: b'?',
    // fn_definition_suffixes: fn_definition_error_suffix!(),


    // fn_definition: b"fn",

    // // used for match statements
    // implies: b"=>",

    // fn_error: b'?',
    // // idk abt this copiolet gave this : fn_error_eq: b"?=",

    // fn_return: b"->",

    // fn_param_start: b'(',
    // fn_param_end: b')',

    // scope_start: b'{',
    // scope_end: b'}',

    // array_start: b'[',
    // array_end: b']',

    // tuple_start: b'(',
    // tuple_end: b')',

    // // make thing that does this

    // // numeric_prefix : {
    // //     // all of these patterns are in numeric prefix and also their own patterns that  can be used...
    // //     ordinal: b'o',
    // // }


    // // idk about big O
    // ordinal_numeric:b'o' ,

    // // little b is
    // binary_numeric: b'b',

    // // u is unicode. u4u32 would make it into the respective type from that char to the number
    // unicode_numeric: b'u',
    // numeric_hex: b'x' | b"0x",

    // big_endian: b'b',
    // little_endian: b'l',
    // native_endian: b'n',

    // numeric_endian_infixes: big_endian!() | little_endian!() | native_endian!(),
    // numeric_prefixes: ordinal!() |  binary_numeric!(),

    underscore: b'_',
    uppercase: b'A'..=b'Z',
    lowercase: b'a'..=b'z',
    numeric: b'0'..=b'9',

    alphanumeric: lowercase!() | uppercase!() | numeric!(),



    identifier: {
        prefix:{
            raw: b"r\"", // idk about this
        }
        first_char: lower_case!() | uppercase!() | underscore!(),
        rest: alphanumeric!() | underscore!(),

        layout() -> {
            first_char rest
        }
    },

    punctuation: b'!'..=b'/'|b':'..=b'@'|b'['..=b'`'|b'{'..=b'~',

    //TODO: make work -> operators: two_char_operators!() | three_char_operators!()

    operators:  b"==" | b"!=" | b"<=" | b">=" | b"//" | b"**" |
    b"<<" | b">>" | b"r+" | b"r-"| b"r*" | b"r/" | b"r%" | b"r&" | b"r|" |
    b"r^" | b"+=" | b"-=" | b"*=" | b"/=" | b"%=" | b"&=" | b"|=" | b"^=" |
    b"=>" | b"@=" | b"->" | b"<-" | b"<=" | b">=" | b"&&" | b"--" |
    b"::" | b"||" | b"++"| b"?=" | b"===" | b"!==" | b"..." | b"r//" | b"r**" | b"r<<" | b"r>>" | b"//=" | b"**=" | b"<<=" |
    b">>=" | b"??" | b"|:"

    expression: {}


    operator:{
        assignment: {
            op:'=',
            type = "Binary",
            doc = "Assigns the value of the right operand to the left operand",
            precedence = 1,
            associativity = "Right to left",
            layout() -> {
                self::op
            }
        },
        equal_to: {
            op: "==",
            type = "Binary",
            doc = "Checks if the left operand is equal to the right operand",
            precedence = 2,
            associativity = "Left to right",
            layout() -> {
                self::op
            }
        },
        equal_to_location: {
            op: "===",
            type = "Binary",
            doc = "Checks if the location of the left operand is the same as the right operand",
            precedence = 2,
            associativity = "Left to right",
            layout() -> {
                self::op
            }
        },
        not_equal_to: {
            self: "!=",
            type = "Binary",
            doc = "Checks if the left operand is not equal to the right operand",
            precedence = 2,
            associativity = "Left to right",
            layout() -> {
                self::op
            }
        },
        greater_than: {
            op: ">",
            parent = super::expression,
            type = "Binary",
            doc = "Checks if the left operand is greater than the right operand",
            precedence = 3,
            associativity = "Left to right",
            layout() -> { self::op }

            assignment_layout -> { self::op super::expression }
        },
        less_than: {
            self: "<",
            rhs: super::expression,
            type = "Binary",
            doc = "Checks if the left operand is less than the right operand",
            precedence = 3,
            associativity = "Left to right",
            layout() -> {
                self::op
            }
        },
        greater_than_or_equal_to: {
            self: ">=",
            type = "Binary",
            doc = "Checks if the left operand is greater than or equal to the right operand",
            precedence = 3,
            associativity = "Left to right",
        },
        less_than_or_equal_to: {
            self: "<=",
            type = "Binary",
            doc = "Checks if the left operand is less than or equal to the right operand",
            precedence = 3,
            associativity = "Left to right",
        },
        logical_and: {
            self: "&&",
            type = "Binary",
            doc = "Checks if both the left and right operands are true",
            precedence = 4,
            associativity = "Left to right",
        },
        logical_or: {
            self: "||",
            type = "Binary",
            doc = "Checks if either the left or right operand is true",
            precedence = 4,
            associativity = "Left to right",
        },
        logical_not: {
            self: "!",
            type = "Unary",
            doc = "Negates the value of the operand",
            precedence = 5,
            associativity = "Right to left",
        },
        bitwise_and: {
            self: "&",
            type = "Binary",
            doc = "Performs a bitwise AND operation on the left and right operands",
            precedence = 6,
            associativity = "Left to right",
        },
        bitwise_or: {
            self: "|",
            type = "Binary",
            doc = "Performs a bitwise OR operation on the left and right operands",
            precedence = 6,
            associativity = "Left to right",
        },
        bitwise_xor: {
            self: "^",
            type = "Binary",
            doc = "Performs a bitwise XOR operation on the left and right operands",
            precedence = 6,
            associativity = "Left to right",
        },
        bitwise_not: {
            self: "~",
            type = "Unary",
            doc = "Performs a bitwise NOT operation on the operand",
            precedence = 6,
            associativity = "Right to left",
        },
        shift_left: {
            self: "<<",
            type = "Binary",
            doc = "Shifts the bits of the left operand to the left by the number of bits specified by the right operand",
            precedence = 7,
            associativity = "Left to right",
        },
        shift_right: {
            self: ">>",
            type = "Binary",
            doc = "Shifts the bits of the left operand to the right by the number of bits specified by the right operand",
            precedence = 7,
            associativity = "Left to right",
        },
        add: {
            self: "+",
            type = "Binary",
            doc = "Adds the left and right operands",
            precedence = 8,
            associativity = "Left to right",
        },
        subtract: {
            self: "-",
            type = "Binary",
            doc = "Subtracts the right operand from the left operand",
            precedence = 8,
            associativity = "Left to right",
        },
        multiply: {
            self: "*",
            type = "Binary",
            doc = "Multiplies the left and right operands",
            precedence = 9,
            associativity = "Left to right",
        },
        divide: {
            self: "/",
            type = "Binary",
            doc = "Divides the left operand by the right operand",
            precedence = 9,
            associativity = "Left to right",
        },
        modulo: {
            self: "%",
            type = "Binary",
            doc = "Calculates the remainder of the left operand divided by the right operand",
            precedence = 9,
            associativity = "Left to right",
        },
        exponent: {
            self: "**",
            type = "Binary",
            doc = "Raises the left operand to the power of the right operand",
            precedence = 10,
            associativity = "Right to left",
        },
        increment: {
            self: "++",
            type = "Unary",
            doc = "Increments the value of the operand by 1",
            precedence = 11,
            associativity = "Right to left",
        },
        decrement: {
            self: "--",
            type = "Unary",
            doc = "Decrements the value of the operand by 1",
            precedence = 11,
            associativity = "Right to left",
        },







    }

        // TODO: name all of the

}

// TODO: Add this
#[derive(Debug, Clone)]
enum TokenType {
    String,
    Char,
    Numeric,
    Identifier,
    Delimiter,
    Operator,
    Comment,
    None,
// todo make ptr look up table for all match statements

// TODO: make a macro that converts the patten matching of rust to simd instructions
// so it looks like pattrn matching when using it in code, but its actually using simd instructions
